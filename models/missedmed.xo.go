// Package models contains the types for schema 'public'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"errors"
	"time"
)

// MissedMed represents a row from 'public.missed_meds'.
type MissedMed struct {
	MissedID   int       `json:"missed_id"`   // missed_id
	MissedDate time.Time `json:"missed_date"` // missed_date
	MedID      int       `json:"med_id"`      // med_id

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the MissedMed exists in the database.
func (mm *MissedMed) Exists() bool {
	return mm._exists
}

// Deleted provides information if the MissedMed has been deleted from the database.
func (mm *MissedMed) Deleted() bool {
	return mm._deleted
}

// Insert inserts the MissedMed to the database.
func (mm *MissedMed) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if mm._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO public.missed_meds (` +
		`missed_date, med_id` +
		`) VALUES (` +
		`$1, $2` +
		`) RETURNING missed_id`

	// run query
	XOLog(sqlstr, mm.MissedDate, mm.MedID)
	err = db.QueryRow(sqlstr, mm.MissedDate, mm.MedID).Scan(&mm.MissedID)
	if err != nil {
		return err
	}

	// set existence
	mm._exists = true

	return nil
}

// Update updates the MissedMed in the database.
func (mm *MissedMed) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !mm._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if mm._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.missed_meds SET (` +
		`missed_date, med_id` +
		`) = ( ` +
		`$1, $2` +
		`) WHERE missed_id = $3`

	// run query
	XOLog(sqlstr, mm.MissedDate, mm.MedID, mm.MissedID)
	_, err = db.Exec(sqlstr, mm.MissedDate, mm.MedID, mm.MissedID)
	return err
}

// Save saves the MissedMed to the database.
func (mm *MissedMed) Save(db XODB) error {
	if mm.Exists() {
		return mm.Update(db)
	}

	return mm.Insert(db)
}

// Upsert performs an upsert for MissedMed.
//
// NOTE: PostgreSQL 9.5+ only
func (mm *MissedMed) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if mm._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.missed_meds (` +
		`missed_id, missed_date, med_id` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) ON CONFLICT (missed_id) DO UPDATE SET (` +
		`missed_id, missed_date, med_id` +
		`) = (` +
		`EXCLUDED.missed_id, EXCLUDED.missed_date, EXCLUDED.med_id` +
		`)`

	// run query
	XOLog(sqlstr, mm.MissedID, mm.MissedDate, mm.MedID)
	_, err = db.Exec(sqlstr, mm.MissedID, mm.MissedDate, mm.MedID)
	if err != nil {
		return err
	}

	// set existence
	mm._exists = true

	return nil
}

// Delete deletes the MissedMed from the database.
func (mm *MissedMed) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !mm._exists {
		return nil
	}

	// if deleted, bail
	if mm._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.missed_meds WHERE missed_id = $1`

	// run query
	XOLog(sqlstr, mm.MissedID)
	_, err = db.Exec(sqlstr, mm.MissedID)
	if err != nil {
		return err
	}

	// set deleted
	mm._deleted = true

	return nil
}

// Med returns the Med associated with the MissedMed's MedID (med_id).
//
// Generated from foreign key 'missed_meds_med_id_fkey'.
func (mm *MissedMed) Med(db XODB) (*Med, error) {
	return MedByMedID(db, mm.MedID)
}

// MissedMedByMissedID retrieves a row from 'public.missed_meds' as a MissedMed.
//
// Generated from index 'missed_meds_pkey'.
func MissedMedByMissedID(db XODB, missedID int) (*MissedMed, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`missed_id, missed_date, med_id ` +
		`FROM public.missed_meds ` +
		`WHERE missed_id = $1`

	// run query
	XOLog(sqlstr, missedID)
	mm := MissedMed{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, missedID).Scan(&mm.MissedID, &mm.MissedDate, &mm.MedID)
	if err != nil {
		return nil, err
	}

	return &mm, nil
}
